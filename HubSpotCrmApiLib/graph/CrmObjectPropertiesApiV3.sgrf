<?xml version="1.0" encoding="UTF-8"?>
<Graph author="Martin" category="others" created="Sat Jan 09 19:55:05 CET 2021" description="This subgraph provides several basic operations for manipulating HubSpot CRM objects.&#13;&#10;&#13;&#10;Supported operations&#13;&#10;&#13;&#10;List - get all objects&#13;&#10;Read - gets data for object by it's ID&#13;&#10;Update - updates the HubSpot object &#13;&#10;Archive - moves the object to trash" guiVersion="6.7.1.5" id="1610452798055" largeIconPath="${PROJECT}/icons/HubSpot-64.png" licenseCode="CLP1DCLOVE28718064BY" mediumIconPath="${PROJECT}/icons/HubSpot-32.png" name="getAssociatedObjectIds(APIv3)" nature="subgraph" showComponentDetails="true" smallIconPath="${PROJECT}/icons/HubSpot-16.png">
<Global>
<inputPorts>
<singlePort connected="true" keepEdge="false" name="0" required="false"/>
</inputPorts>
<outputPorts>
<singlePort connected="true" keepEdge="true" name="0" required="false"/>
<singlePort connected="true" keepEdge="true" name="1" required="false"/>
</outputPorts>
<Metadata id="Metadata4">
<Record fieldDelimiter="|" name="Dummy" recordDelimiter="\r\n" type="delimited">
<Field name="Debug" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata5">
<Record fieldDelimiter="|" name="Error" previewAttachmentCharset="UTF-8" recordDelimiter="\n" type="delimited">
<Field name="status_code" trim="true" type="integer"/>
<Field name="response_body" type="string"/>
<Field name="error_message" type="string"/>
<Field name="object_id" type="string"/>
<Field name="request_id" trim="true" type="long"/>
</Record>
</Metadata>
<Metadata id="Metadata3">
<Record fieldDelimiter="|" name="Object_ID_And_HTTPConnector_Request" previewAttachmentCharset="UTF-8" recordDelimiter="\n" type="delimited">
<Field name="Object_ID" type="string"/>
<Field name="URL" type="string"/>
<Field name="requestContent" type="string"/>
<Field name="errorMessage" type="string"/>
<Field containerType="map" name="AdditinalHTTPHeaders" type="string"/>
</Record>
</Metadata>
<Metadata id="HTTPConnector_Response">
<Record fieldDelimiter="|" name="Object_ID_And_HTTPConnector_Response" previewAttachmentCharset="UTF-8" recordDelimiter="\n" type="delimited">
<Field name="Object_ID" type="string"/>
<Field name="content" type="string"/>
<Field name="statusCode" trim="true" type="integer"/>
<Field name="errorMessage" type="string"/>
<Field name="reqestContent" type="string"/>
<Field name="URL" type="string"/>
<Field containerType="map" name="AdditinalHTTPHeaders" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata2">
<Record fieldDelimiter="|" name="ParsedResponseResult" previewAttachmentCharset="UTF-8" recordDelimiter="\r\n" type="delimited">
<Field name="object_id" type="string"/>
<Field name="request_id" type="long"/>
<Field name="parsed_result" type="variant"/>
</Record>
</Metadata>
<Metadata id="Metadata6">
<Record fieldDelimiter="|" name="Property" previewAttachmentCharset="UTF-8" recordDelimiter="\r\n" type="delimited">
<Field name="name" type="string"/>
<Field name="label" type="string"/>
<Field name="groupName" type="string"/>
<Field name="type" type="string"/>
<Field name="fieldType" type="string"/>
<Field name="options" type="variant"/>
<Field name="description" type="string"/>
<Field name="displayOrder" type="integer"/>
<Field name="calculated" type="boolean"/>
<Field name="externalOptions" type="boolean"/>
<Field name="hasUniqueValue" type="boolean"/>
<Field name="hidden" type="boolean"/>
<Field name="hubspotDefined" type="boolean"/>
<Field name="modificationMetadata" type="variant"/>
<Field name="formField" type="boolean"/>
</Record>
</Metadata>
<Metadata id="Metadata1">
<Record fieldDelimiter="|" name="RequestId" previewAttachmentCharset="UTF-8" recordDelimiter="\r\n" type="delimited">
<Field name="_request_id" type="long"/>
<Field name="_processing_error" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata0">
<Record fieldDelimiter="|" name="test" previewAttachmentCharset="UTF-8" recordDelimiter="\r\n" type="delimited">
<Field name="Deal_ID" type="string"/>
</Record>
</Metadata>
<GraphParameters>
<GraphParameter label="HS object name" name="OBJECT" public="true" required="true" value="products">
<attr name="description"><![CDATA[Use one of the provided values or provide your own for a custom object.]]></attr>
<SingleType allowCustomValues="true" name="simpleEnum" values="companies;contacts;deals;line_items;products;tickets;quotes"/>
</GraphParameter>
<GraphParameter label="HS properties to metadata mapping" name="FIELD_MAPPING" public="false" required="false">
<attr name="description"><![CDATA[Provide mapping between HubSpot property names and Clover metadata field names, in the .properties file format. Left side represents HubSpot names, right side represents Clover names. Clover names are optional, if blank the HubSpot name will be used.]]></attr>
<attr name="value"><![CDATA[name=
groupName=
type=
fieldType=
description=
label=
options=
displayOrder=
calculated=
externalOptions=
hasUniqueValue=
hidden=
hubspotDefined=
modificationMetadata=
formField=
]]></attr>
<SingleType name="properties"/>
</GraphParameter>
<GraphParameter label="REQUEST_METHOD" name="REQUEST_METHOD" public="false" required="false">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	switch("${OPERATION}"){
		case "Read":
			return "GET";
		case "Create":
			return "POST";
		case "Update":
			return "PATCH";
		case "Archive":
			return "DELETE";
		case "List":
			return "GET";
		default: 
			raiseError("Unknown operation parameter value when derriving request method");
	}
}
]]></attr>
</GraphParameter>
<GraphParameter label="Operation" name="OPERATION" public="true" required="false" value="List">
<attr name="description"><![CDATA[Select one of the operations List, Read, Create, Update, Archive(move to trash).]]></attr>
<SingleType allowCustomValues="false" name="simpleEnum" values="Read|Read - Not yet implemented;Create|Create - Not yet implemented;Update|Update - Not yet implemented;Archive|Archive - Not yet implemented;List"/>
</GraphParameter>
<GraphParameter label="DESIRED_RESPONSE_STATUS" name="DESIRED_RESPONSE_STATUS" public="false" required="false">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	switch("${OPERATION}"){
		case "Read":
			return "200";
		case "Create":
			return "201";
		case "Update":
			return "200";
		case "Archive":
			return "204";
		case "List":
			return "200";
		default: 
			raiseError("Unknown operation parameter value when derriving sucess response status");
	}
}

]]></attr>
</GraphParameter>
<GraphParameter category="advanced" defaultHint="Optional - object name plus id suffix will be used automatically" label="Object ID field name" name="OBJECT_ID_FIELD_NAME" public="false" secure="false">
<attr name="dynamicValue"><![CDATA[//#CTL2
function string getValue() {
	return lowerCase(singular(getParamValue("OBJECT")))+"_id";
}

function string singular(string noun){
	if(endsWith(noun,'ies')){
		return left(noun, length(noun)-3) + "y";
	}else if(endsWith(noun,'s')){
		return left(noun, length(noun)-1);
	}else{
		return noun;
	}
}
]]></attr>
<attr name="description"><![CDATA[Clover field name mapped to the HubSpot ID. Optional, if no value provided, field name will be generated as lowercase singular object name + _id suffix.]]></attr>
<SingleType edge="Edge6" fieldType="string" name="field"/>
</GraphParameter>
<GraphParameter category="advanced" label="Look in archived records?" name="ARCHIVED" public="true" value="false">
<attr name="description"><![CDATA[Switches between working on regular or archived records (in trash)]]></attr>
<SingleType name="bool"/>
</GraphParameter>
<GraphParameter name="IS_LIST_OPERATION">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	return getParamValue("OPERATION") == "List"? "true" : "false";
}
]]></attr>
</GraphParameter>
<GraphParameter name="NOT_IS_LIST_OPERATION">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	return getParamValue("IS_LIST_OPERATION")=="true"?"false":"true";
}
]]></attr>
</GraphParameter>
<GraphParameter name="TRASHIFY_WHEN_ARCHIVE_OPERATION">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	return "${OPERATION}" == "Archive"? "trash":"true";
}
]]></attr>
</GraphParameter>
<GraphParameter name="IS_ARCHIVE_OPERATION">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	return getParamValue("OPERATION") == "Archive"? "true" : "false";;
}
]]></attr>
</GraphParameter>
<GraphParameter name="NOT_IS_ARCHIVE_OPERATION">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	return getParamValue("OPERATION") == "Archive"? "false" : "true";
}
]]></attr>
</GraphParameter>
<GraphParameter name="API_CALL_SUBGRAPH">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	string api_call_subgraph;
	
	if (not isBlank(getParamValue("PRIVATE_APP_TOKEN"))){
		api_call_subgraph = "${SUBGRAPH_DIR}/ApiCall-PrivateApp.sgrf";
	} else {
		api_call_subgraph = "${SUBGRAPH_DIR}/ApiCall-Oauth2.sgrf";
	}
	return api_call_subgraph;
}
]]></attr>
</GraphParameter>
<GraphParameterFile fileURL="workspace.prm"/>
<GraphParameterFile fileURL="library.prm"/>
</GraphParameters>
<RichTextNote backgroundColor="DAD8C9" folded="false" fontSize="medium" height="566" id="Note0" textColor="444444" width="689" x="-371" y="-516">
<attr name="text"><![CDATA[h1. HubSpot CRM Object Properties API V3

This subgraph provides means to interact with the object's schema.

See https://developers.hubspot.com/docs/api/crm/properties

The subgraph supports two authorization methods accepted by HubSpot:
* Private apps
* OAuth2 - pass in URL of the .cfg file for CloverDX OAuth2 HubSpot connection

If Private App token is not provided OAuth2 method is used.

*Metadata:*
Input:
* _request_id and _processing_error are reserved field names
* must contain a field (string) with the id of the object. The name of the field can be set by a parameter. Defaults to the object type name plus _id suffix , e.g. deal_id. Attempts a conversion of the name to singular.
Output:
* a copy by name operation is applied from the input, before merging with the result of the request so you can pass additional fields through.

*Rate limit*
The connector should be able to adapt to the API rate limit, however this is not properly tested yet.]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="FAF6D6" folded="false" fontSize="medium" height="566" id="Note1" textColor="444444" width="807" x="334" y="-516">
<attr name="text"><![CDATA[h3. Operations

* *List* - gets all object's properties
* *-Read-* - not yet implemented
* *-Create-* - not yet implemented
* *-Update-* - not yet implemented
* *-Archive-* - not yet implemented
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="FAF6D6" folded="false" fontSize="medium" height="346" id="Note2" textColor="444444" width="583" x="150" y="151">
<attr name="text"><![CDATA[h3. Main loop (Paging)]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="F9EB81" folded="false" fontSize="medium" height="238" id="Note3" textColor="444444" width="329" x="-772" y="-267">
<attr name="text"><![CDATA[h3. TODO

* check config
** correct ports connected based on operation?
** exactly one auth method provided
* associations
* option to use metadata as implicit mapping]]></attr>
</RichTextNote>
<Dictionary>
<Entry input="false" name="JSON_MAPPING" output="false" type="string"/>
</Dictionary>
</Global>
<Phase number="0">
<Node __HTTP_CALL_RETRY_COUNT="${HTTP_CALL_RETRY_COUNT}" __HTTP_CALL_RETRY_DELAY="${HTTP_CALL_RETRY_DELAY}" __HTTP_CALL_SUCCESS_STATUS_CODE="${DESIRED_RESPONSE_STATUS}" __HTTP_CALL_TIMEOUT="${HTTP_CALL_TIMEOUT}" __O_AUTH2_CONNECTION="${O_AUTH2_CONNECTION}" __PRIVATE_APP_TOKEN="${PRIVATE_APP_TOKEN}" guiName="Call HubSpot API" guiX="366" guiY="378" id="CALL_HUB_SPOT_API" jobURL="${API_CALL_SUBGRAPH}" skipCheckConfig="false" type="SUBGRAPH"/>
<Node debugInput="true" guiName="DataGenerator" guiX="-1001" guiY="80" id="DATA_GENERATOR" type="DATA_GENERATOR"/>
<Node debugOutput="true" guiName="Data port" guiX="2094" guiY="66" id="DATA_PORT" type="TRASH"/>
<Node enabled="${NOT_IS_LIST_OPERATION}" guiName="Dummy metadata provider" guiX="-462" guiY="195" id="DUMMY_METADATA_PROVIDER" type="DATA_GENERATOR">
<attr name="generate"><![CDATA[//#CTL2

// Generates output record.
function integer generate() {
	return ALL;
}]]></attr>
</Node>
<Node enabled="${NOT_IS_ARCHIVE_OPERATION}" guiName="Dummy metadata provider" guiX="1172" guiY="195" id="DUMMY_METADATA_PROVIDER1" type="DATA_GENERATOR">
<attr name="generate"><![CDATA[//#CTL2

// Generates output record.
function integer generate() {
	return ALL;
}]]></attr>
</Node>
<Node enabled="${NOT_IS_LIST_OPERATION}" guiName="Enrich meta" guiX="-436" guiY="80" id="ENRICH_META" type="CROSS_JOIN">
<attr name="transform"><![CDATA[//#CTL2
long request_id = 0;
// Transforms input record into output record.
function integer transform() {
	$out.0.* = $in.0.*;
	$out.0._request_id = request_id++;
	return ALL;
}
]]></attr>
</Node>
<Node enabled="${NOT_IS_ARCHIVE_OPERATION}" guiName="Enrich meta" guiX="1509" guiY="195" id="ENRICH_META1" type="CROSS_JOIN"/>
<Node debugOutput="true" guiName="Error port" guiX="2094" guiY="326" id="ERROR_PORT" type="TRASH"/>
<Node guiName="Extract paging" guiX="550" guiY="378" id="EXTRACT_PAGING" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2
integer DESIRED_RESPONSE_STATUS = str2integer(getParamValue("DESIRED_RESPONSE_STATUS"));
string OPERATION = getParamValue("OPERATION");

// Transforms input record into output record.
function integer transform() {
	
	$out.0.* = $in.0.*;
	
	if( not isBlank($in.0.httpResponseErrorMessage)
			or
		$in.0.httpResponseStatusCode != DESIRED_RESPONSE_STATUS
	){
		$out.0.* = $in.0.*;
		$out.0.is_error = true;
		return 0;
	}
	
	variant parsedResponseBody ;
	
	try{
		parsedResponseBody = parseJson($in.0.httpResponseBody);
	}catch (CTLException ex){
		$out.0.is_error = true;
		$out.0.httpResponseErrorMessage = "Parsing response failed with following error:" + ex.message;
	}
	
	//this should not happen unless there is an error on HubSpot side	
	if( (isnull(parsedResponseBody) or isEmpty(parsedResponseBody))
			and 
		$in.0.httpResponseStatusCode != 204) //204 = no content
	{ 
		$out.0.is_error = true;
		$out.0.httpResponseErrorMessage = "Parsing response failed - no content";
	}
	
	
	
	//=======PAGING==========
	
	if(OPERATION == "List"){
	
		/* Is there a next page? Parse the section of document that coul look like this
		 * "paging": {
		 *    "next": {
		 *       "after": "...",
		 *       "link": "..." <- this contains the whole url with all the parametermeters necessary to get next page
		 */
		if(	containsKey(parsedResponseBody,"paging")
				and
			containsKey(parsedResponseBody["paging"],"next")
		){
			$out.0.has_next = true;
			//set url for next request to next page
			$out.0.httpRequestUrl = cast(parsedResponseBody["paging"]["next"]["link"],string);
		}else{
			$out.0.has_next = false;
		}
	}else{
		$out.0.has_next = false;
	}
	
	//pass out result
	
	$out.1.object_id = $in.0.object_id;
	$out.1.request_id = $in.0.request_id;
	$out.1.parsed_result = parsedResponseBody;
	
	return ALL;
}
]]></attr>
</Node>
<Node enabled="${IS_LIST_OPERATION}" guiName="Generate List operation token" guiX="-760" guiY="195" id="GENERATE_LIST_OPERATION_TOKEN" type="DATA_GENERATOR">
<attr name="generate"><![CDATA[//#CTL2

// Generates output record.
function integer generate() {
	$out.0._request_id = 0;
	return ALL;
}]]></attr>
</Node>
<Node enabled="${TRASHIFY_WHEN_ARCHIVE_OPERATION}" guiName="Join with orig record" guiX="1172" guiY="66" id="JOIN_WITH_ORIG_RECORD" joinKey="$_request_id=$_request_id" slaveDuplicates="true" type="EXT_HASH_JOIN">
<attr name="transform"><![CDATA[//#CTL2

//==============>INIT<======================
map[string,string] mapping = parseProperties(getParamValue("FIELD_MAPPING"));
string[] hubspot_property_names = getKeys(mapping);
string[] clover_field_names;
	
foreach(string hubspot_property_name: hubspot_property_names){
	string clover_field_name = mapping[hubspot_property_name];
	if(not isBlank(clover_field_name)){
		append(clover_field_names, clover_field_name);
	}else{
		//apply default clover field name = hubspot property name
		append(clover_field_names, hubspot_property_name);
	}
}

//===========>TRANSFORMATION<================

// Transforms input record into output record.
function integer transform() {
	//copy pass throught values
	$out.0.* = $in.1.*;
	//overwrite new values
	if("${OPERATION}".in(["Read","List"])){
		foreach(string field_name : clover_field_names){
			setValue($out.0,field_name,getValue($in.0,field_name));
		}
	}
	return ALL;
}]]></attr>
</Node>
<Node guiName="Loop" guiX="184" guiY="237" id="LOOP" loggingLevel="off" type="LOOP">
<attr name="whileCondition"><![CDATA[//#CTL2
$in.0.has_next and not $in.0.is_error]]></attr>
</Node>
<Node enabled="${NOT_IS_ARCHIVE_OPERATION}" guiName="Parse to records" guiX="778" guiY="390" id="PARSE_TO_RECORDS" type="NORMALIZER">
<attr name="normalize"><![CDATA[//#CTL2
// This transformation defines the way in which a single input record is normalized
// into multiple output records.

//INIT
boolean runtime_init_complete = true;
map[string,string] mapping = parseProperties(getParamValue("FIELD_MAPPING"));
string[] hubspot_property_names = getKeys(mapping);
string[] clover_field_names;

string OPERATION = getParamValue("OPERATION");
string OBJECT_ID_FIELD_NAME = getParamValue("OBJECT_ID_FIELD_NAME");

variant results_list;
	
foreach(string hubspot_property_name: hubspot_property_names){
	string clover_field_name = mapping[hubspot_property_name];
	if(not isBlank(clover_field_name)){
		append(clover_field_names, clover_field_name);
	}else{
		//apply default clover field name = hubspot property name
		append(clover_field_names, hubspot_property_name);
	}
}

function void runtimeInit() {
	if(getFieldIndex($out.0,OBJECT_ID_FIELD_NAME) == -1){
		raiseError("[Configuration error] Output metadata does not contain field named: " + OBJECT_ID_FIELD_NAME);
	}
	runtime_init_complete = true;
}

// This function is called for all input records.
// It parses each single input record and returns the number of records
// that should be created from such input record.
function integer count() {

	if(OPERATION == "List"){
		results_list = $in.0.parsed_result["results"];
		return length(results_list);	
	}
	return 1;
}

// This function creates new records for the output, based on single input record
// that has been parsed by the count() function.
// It is called count() times for each input record.
// The idx argument specifies which output record is being created,
// its values range is from 0 to count() - 1.
function integer transform(integer idx) {
	
	if(not runtime_init_complete){
		runtimeInit();	
	}
	
	$out.0._request_id = $in.0.request_id;
	try{
		if(OPERATION == "List"){
			parse_object(results_list[idx]);
			
		}else{
			parse_object($in.0.parsed_result);	
		}
	}catch (CTLException ex){
		if(contains(ex.message,"[Parsing error]")){
			$out.0._processing_error = ex.message;
		}else{
			raiseError(ex.message);
		}
	}
	return OK;
}

function void parse_object(variant json){
//	if(OPERATION.in(["List","Create"])){
//		setStringValue(
//			$out.0,
//			OBJECT_ID_FIELD_NAME,
//			cast(json["id"],string)
//		);
//	}else{
//		setStringValue(
//			$out.0,
//			OBJECT_ID_FIELD_NAME,
//			$in.0.object_id
//		);
//	}
	
	for(integer index = 0; index < length(hubspot_property_names); index++){
		
		integer field_index = getFieldIndex($out.0,clover_field_names[index]);
		if(field_index == -1){
			//field not found on output
			raiseError("[Configuration error] Output metadata does not contain field named: " + clover_field_names[index]);
		}
		
		string field_type = getFieldType($out.0,field_index);
		string field_value;
		variant field_variant_value;
		
		try{
			if(field_type != "variant"){
				field_value = trim(cast(json[hubspot_property_names[index]],string)):trim(toString(json[hubspot_property_names[index]]));
			}else{
				field_variant_value = json[hubspot_property_names[index]];
			}
		}catch(CTLException ex){
			printLog(error, ex);
			raiseError("[Configuration error] Property " + hubspot_property_names[index] + " not found in the response - it probably doesn't exist, and has been ignored by HubSpot API");
		}
		
		switch(field_type){
			case "string":
				setStringValue($out.0,field_index,field_value);
				break;
			case "date":
				setDateValue(
					$out.0,
					field_index,
					isBlank(field_value)?null:str2date(field_value,"iso-8601:dateTime")
				);
				break;
			case "long":
				long long_value;
				try{
					 long_value = isBlank(field_value)?null:str2long(chop_fractional_part_from_decimal_if_zero(field_value));
				}catch(CTLException ex){
					printLog(error, ex);
					raiseError(parsing_error(field_value,hubspot_property_names[index],field_type,ex));
				}
				setLongValue(
					$out.0,
					field_index,
					long_value
				);
				break;
			case "integer":
				integer integer_value;
				try{
					integer_value = isBlank(field_value)?null:str2integer(chop_fractional_part_from_decimal_if_zero(field_value));
				}catch(CTLException ex){
					printLog(error, ex);
					raiseError(parsing_error(field_value,hubspot_property_names[index],field_type,ex));
				}
				setIntValue(
					$out.0,
					field_index,
					integer_value
				);
				break;
			case "decimal":
				decimal decimal_value;
				try{
					decimal_value = isBlank(field_value)?null:str2decimal(field_value);
				}catch(CTLException ex){
					printLog(error, ex);
					raiseError(parsing_error(field_value,hubspot_property_names[index],field_type,ex));
				}
				setDecimalValue(
					$out.0,
					field_index,
					decimal_value
				);
				break;
			case "number":
				double double_value;
				try{
					double_value = isBlank(field_value)?null:str2double(field_value);
				}catch(CTLException ex){
					printLog(error, ex);
					raiseError(parsing_error(field_value,hubspot_property_names[index],field_type,ex));
				}
				setNumValue(
					$out.0,
					field_index,
					double_value
				);
				break;
			case "variant":
				setValue($out.0,
					field_index,
					field_variant_value
				);
				break;
			case "boolean":
				boolean boolean_value;
				try{
					 boolean_value = isBlank(field_value)?null:str2bool(lowerCase(field_value)):str2bool(field_value,getFieldProperties($out.0,field_index)["format"]);
				}catch(CTLException ex){
					printLog(error, ex);
					raiseError(parsing_error(field_value,hubspot_property_names[index],field_type,ex));
				}
				setBoolValue(
					$out.0,
					field_index,
					boolean_value
				);
				break;
			default:
				raiseError("[Not implemented] Conversion for field " + clover_field_names[index] + " of type " +  field_type + " not implemented");
		}

	}
	
		
}

/**
 * Parse string using Clover bool patterns.
 *
 * Only simple case supported - First separator needs to be same as last character and at least the A and B clause needs to provided.
 */
function boolean str2bool(string value, string format){
	string separator = charAt(format,0);
	if(isBlank(format)){
		raiseError("Format for conversion is blank.");	
	}
	if(charAt(format,length(format)-1) != separator){
		raiseError("Only patterns beginning and ending with the same separator character.");
	}
	string[] parts = format.split(separator);
	if(parts.length() < 2 or isBlank(parts[0]) or isBlank(parts[1])){
		raiseError("Invalid format pattern.");
	}
	
	if(value.matches(parts[0])){
		return true;	
	}else if(value.matches(parts[1])){
		return false;
	}else{
		raiseError("Value: " + value + " cannot be parsed as boolean (using pattern: " + format + ")" );
	}
}

function string parsing_error(string field_value, string field_name, string field_type, CTLException exception){
	return concat(
		"[Parsing error] Error parsing value of property ",
		field_name,
		" with value ",
		field_value,
		" to type ",
		field_type,
		" . Cause: ",
		exception.cause,
		" Error message : ",
		exception.message
	);
}

function string chop_fractional_part_from_decimal_if_zero(string input){
	if(matches(input,'\d*\.0*')){
		return chop(input,'\.0*');
	}else{
		return input;
	}
}]]></attr>
</Node>
<Node guiName="Prepare payload and URL" guiX="-78" guiY="237" id="PREPARE_PAYLOAD_AND_URL" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2
import "${TRANS_DIR}/Utils.ctl";
// Transforms input record into output record.

//==============>INIT<======================
map[string,string] mapping = parseProperties(getParamValue("FIELD_MAPPING"));
string[] hubspot_property_names = getKeys(mapping);
string[] clover_field_names;
string properties = join(",",hubspot_property_names);
	
foreach(string hubspot_property_name: hubspot_property_names){
	string clover_field_name = mapping[hubspot_property_name];
	if(not isBlank(clover_field_name)){
		append(clover_field_names, clover_field_name);
	}else{
		//apply default clover field name = hubspot property name
		append(clover_field_names, hubspot_property_name);
	}
}

string OBJECT_ID_FIELD_NAME = getParamValue("OBJECT_ID_FIELD_NAME");
string OPERATION = getParamValue("OPERATION");
string OBJECT = getParamValue("OBJECT");
string REQUEST_METHOD = getParamValue("REQUEST_METHOD");
string LIMIT = getParamValue("LIMIT"); 
string ASSOCIATIONS = getParamValue("ASSOCIATIONS");
string ARCHIVED = getParamValue("ARCHIVED");
string base_api_url = "https://api.hubapi.com/crm/v3/properties/";

//=============>TRANSFORMATION<=============

function integer transform() {
	
	$out.0.request_id = $in.0._request_id;
	$out.0.httpRequestCharset = "UTF-8";
	$out.0.has_next = true;
	$out.0.is_error = false;
	$out.0.httpRequestMethod = REQUEST_METHOD;
	
	string id;
	
	switch (OPERATION){
		case "List":
			$out.0.httpRequestUrl = concat(
				base_api_url,
				OBJECT,
				format_query_parameters({
					"archived" -> ARCHIVED == "true" ? "true": null,
					"limit" -> LIMIT
				})
			);
			break;
			
		case "Read":
			id = getStringValue($in.0,OBJECT_ID_FIELD_NAME);
			$out.0.object_id = id;
			if(isBlank(id)){
				$out.0.is_error = true;
				$out.0.httpResponseErrorMessage = "Object id cannot be blank.";
				return ALL;
			}
			
			$out.0.httpRequestUrl = concat(
				base_api_url,
				OBJECT,"/",
				id,
				(ARCHIVED == "true" ? "&archived=true": "") //false is API defaul
			);
			break;
		
		case "Create":	
			$out.0.httpRequestBody =  buildRequestBody();
			$out.0.httpRequestUrl = concat(
				base_api_url,
				OBJECT
			);
			$out.0.httpRequestHeaders = {"content-type" -> "application/json"};
			break;
		
		case "Update":
			id = getStringValue($in.0,OBJECT_ID_FIELD_NAME);
			$out.0.object_id = id;
			if(isBlank(id)){
				$out.0.is_error = true;
				$out.0.httpResponseErrorMessage = "Object id cannot be blank.";
				return ALL;
			}
			
			$out.0.httpRequestBody =  buildRequestBody();
			$out.0.httpRequestUrl = concat(
				base_api_url,
				OBJECT,"/",
				id
			);
			$out.0.httpRequestHeaders = {"content-type" -> "application/json"};
			break;
		
		case "Archive":
			id = getStringValue($in.0,OBJECT_ID_FIELD_NAME);
			$out.0.object_id = id;
			if(isBlank(id)){
				$out.0.is_error = true;
				$out.0.httpResponseErrorMessage = "Object id cannot be blank.";
				return ALL;
			}
			
			$out.0.httpRequestUrl = concat(
				base_api_url,
				OBJECT,"/",
				id
			);
			break;
	}
	return ALL;
}

function string buildRequestBody(){
	variant properties = {};
	
	for(integer index = 0; index < length(hubspot_property_names); index++){
		properties[hubspot_property_names[index]] = getValue($in.0,clover_field_names[index]);
	}
	return writeJson({"properties" -> properties});
}]]></attr>
</Node>
<Node enabled="${NOT_IS_ARCHIVE_OPERATION}" guiName="Raise error" guiX="1013" guiY="390" id="RAISE_ERROR" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2
string OBJECT_ID_FIELD_NAME = getParamValue("OBJECT_ID_FIELD_NAME");
// Transforms input record into output record.
function integer transform() {
	
	if(isBlank($in.0._processing_error)){
		$out.0.* = $in.0.*;
		return 0;
	}else{
		if(isSubgraphOutputPortConnected(1)){
			$out.1.error_message = $in.0._processing_error;
			$out.1.object_id = getStringValue($in.0, OBJECT_ID_FIELD_NAME);
			$out.1.request_id = $in.0._request_id;
			return 1;
		}
		raiseError( "Processing response failed on object: " 
			+ getStringValue($in.0, OBJECT_ID_FIELD_NAME) 
			+ " with message: " 
			+ $in.0._processing_error
		);
	}
}
]]></attr>
</Node>
<Node guiName="Raise error or send to port" guiX="1485" guiY="326" id="RAISE_ERROR_OR_SEND_TO_PORT" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	if(not $in.0.is_error){
		return SKIP;
	}
	
	if(isSubgraphOutputPortConnected(1)){
		$out.0.status_code = $in.0.httpResponseStatusCode;
		$out.0.response_body = $in.0.httpResponseBody;
		$out.0.error_message = $in.0.httpResponseErrorMessage;
		$out.0.object_id = $in.0.object_id;
		$out.0.request_id = $in.0.request_id;
		return 0;
	}	
	raiseError( "HubSpot API call failed. \n Status: " + num2str($in.0.httpResponseStatusCode)
		+ "\n Error message: " +$in.0.httpResponseErrorMessage
		+ "\n Response body: " +$in.0.httpResponseBody
	);
}

]]></attr>
</Node>
<Node guiName="Remove request id from meta" guiX="1474" guiY="66" id="REMOVE_REQUEST_ID_FROM_META" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	$out.0.* = $in.0.*;

	return ALL;
}
]]></attr>
</Node>
<Node guiName="SimpleCopy" guiX="-232" guiY="80" id="SIMPLE_COPY" type="SIMPLE_COPY"/>
<Node guiName="SimpleGather" guiX="1793" guiY="326" id="SIMPLE_GATHER1" type="SIMPLE_GATHER"/>
<Node guiName="SimpleGather" guiX="-717" guiY="80" id="SIMPLE_GATHER2" type="SIMPLE_GATHER"/>
<Node guiName="SubgraphInput" guiX="-825" guiY="-511" id="SUBGRAPH_INPUT0" type="SUBGRAPH_INPUT">
<Port guiY="97" name="0"/>
<Port guiY="187" name="1"/>
</Node>
<Node guiName="SubgraphOutput" guiX="2007" guiY="-511" id="SUBGRAPH_OUTPUT0" type="SUBGRAPH_OUTPUT">
<Port guiY="83" name="0"/>
<Port guiY="343" name="1"/>
<Port guiY="496" name="2"/>
</Node>
<Node enabled="${NOT_IS_ARCHIVE_OPERATION}" guiName="Trash" guiX="1793" guiY="195" id="TRASH" type="TRASH"/>
<Edge fromNode="CALL_HUB_SPOT_API:0" guiBendpoints="" guiRouter="Manhattan" id="Edge13" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="EXTRACT_PAGING:0"/>
<Edge fromNode="DATA_GENERATOR:0" guiBendpoints="" guiRouter="Manhattan" id="Edge12" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 0 (out)" toNode="SUBGRAPH_INPUT0:0"/>
<Edge fromNode="DUMMY_METADATA_PROVIDER:0" guiBendpoints="" guiRouter="Manhattan" id="Edge25" inPort="Port 1 (slave)" metadata="Metadata1" outPort="Port 0 (out)" toNode="ENRICH_META:1"/>
<Edge fromNode="DUMMY_METADATA_PROVIDER1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge31" inPort="Port 0 (master)" metadataRef="#//Edge30" outPort="Port 0 (out)" toNode="ENRICH_META1:0"/>
<Edge fromNode="DUMMY_METADATA_PROVIDER1:1" guiBendpoints="" guiRouter="Manhattan" id="Edge29" inPort="Port 1 (slave)" metadata="Metadata1" outPort="Port 1 (out)" toNode="ENRICH_META1:1"/>
<Edge fromNode="ENRICH_META:0" guiBendpoints="" guiRouter="Manhattan" id="Edge15" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="SIMPLE_COPY:0"/>
<Edge fromNode="ENRICH_META1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge32" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="TRASH:0"/>
<Edge fromNode="EXTRACT_PAGING:0" guiBendpoints="" guiRouter="Manhattan" id="Edge33" inPort="Port 1 (back from loop)" outPort="Port 0 (out)" toNode="LOOP:1"/>
<Edge fromNode="EXTRACT_PAGING:1" guiBendpoints="" guiRouter="Manhattan" id="Edge34" inPort="Port 0 (in)" metadata="Metadata2" outPort="Port 1 (out)" toNode="PARSE_TO_RECORDS:0"/>
<Edge fromNode="GENERATE_LIST_OPERATION_TOKEN:0" guiBendpoints="" guiRouter="Manhattan" id="Edge27" inPort="Port 1 (in)" metadataRef="#//Edge7" outPort="Port 0 (out)" toNode="SIMPLE_GATHER2:1"/>
<Edge fromNode="JOIN_WITH_ORIG_RECORD:0" guiBendpoints="" guiRouter="Manhattan" id="Edge7" inPort="Port 0 (in)" metadataRef="#//Edge32" outPort="Port 0 (out)" toNode="REMOVE_REQUEST_ID_FROM_META:0"/>
<Edge fromNode="LOOP:0" guiBendpoints="" guiRouter="Manhattan" id="Edge17" inPort="Port 0 (in)" outPort="Port 0 (end of loop)" toNode="RAISE_ERROR_OR_SEND_TO_PORT:0"/>
<Edge fromNode="LOOP:1" guiBendpoints="" guiRouter="Manhattan" id="Edge16" inPort="Port 0 (in)" outPort="Port 1 (continue loop)" toNode="CALL_HUB_SPOT_API:0"/>
<Edge fromNode="PARSE_TO_RECORDS:0" guiBendpoints="" guiRouter="Manhattan" id="Edge35" inPort="Port 0 (in)" metadataRef="#//Edge7" outPort="Port 0 (out)" toNode="RAISE_ERROR:0"/>
<Edge fromNode="PREPARE_PAYLOAD_AND_URL:0" guiBendpoints="" guiRouter="Manhattan" id="Edge3" inPort="Port 0 (input token)" outPort="Port 0 (out)" toNode="LOOP:0"/>
<Edge fromNode="RAISE_ERROR:0" guiBendpoints="" guiRouter="Manhattan" id="Edge0" inPort="Port 0 (driver)" outPort="Port 0 (out)" toNode="JOIN_WITH_ORIG_RECORD:0"/>
<Edge fromNode="RAISE_ERROR:1" guiBendpoints="" guiRouter="Manhattan" id="Edge9" inPort="Port 1 (in)" outPort="Port 1 (out)" toNode="SIMPLE_GATHER1:1"/>
<Edge fromNode="RAISE_ERROR_OR_SEND_TO_PORT:0" guiBendpoints="" guiRouter="Manhattan" id="Edge36" inPort="Port 0 (in)" metadata="Metadata5" outPort="Port 0 (out)" toNode="SIMPLE_GATHER1:0"/>
<Edge fromNode="REMOVE_REQUEST_ID_FROM_META:0" guiBendpoints="" guiRouter="Manhattan" id="Edge30" inPort="Port 0 (in)" metadata="Metadata6" outPort="Port 0 (out)" toNode="SUBGRAPH_OUTPUT0:0"/>
<Edge fromNode="SIMPLE_COPY:0" guiBendpoints="" guiRouter="Manhattan" id="Edge6" inPort="Port 1 (slave)" outPort="Port 0 (out)" toNode="JOIN_WITH_ORIG_RECORD:1"/>
<Edge fromNode="SIMPLE_COPY:1" guiBendpoints="" guiRouter="Manhattan" id="Edge4" inPort="Port 0 (in)" outPort="Port 1 (out)" toNode="PREPARE_PAYLOAD_AND_URL:0"/>
<Edge fromNode="SIMPLE_GATHER1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge10" inPort="Port 1 (in)" outPort="Port 0 (out)" toNode="SUBGRAPH_OUTPUT0:1"/>
<Edge fromNode="SIMPLE_GATHER2:0" guiBendpoints="" guiRouter="Manhattan" id="Edge26" inPort="Port 0 (master)" outPort="Port 0 (out)" toNode="ENRICH_META:0"/>
<Edge fromNode="SUBGRAPH_INPUT0:0" guiBendpoints="" guiRouter="Manhattan" id="Edge2" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="SIMPLE_GATHER2:0"/>
<Edge fromNode="SUBGRAPH_OUTPUT0:0" guiBendpoints="" guiRouter="Manhattan" id="Edge1" inPort="Port 0 (in)" metadata="Metadata6" outPort="Port 0 (out)" toNode="DATA_PORT:0"/>
<Edge fromNode="SUBGRAPH_OUTPUT0:1" guiBendpoints="" guiRouter="Manhattan" id="Edge5" inPort="Port 0 (in)" outPort="Port 1 (out)" toNode="ERROR_PORT:0"/>
</Phase>
</Graph>
